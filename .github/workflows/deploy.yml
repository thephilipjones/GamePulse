name: Deploy to AWS EC2

on:
  push:
    branches:
      - main

# Required for OIDC authentication with AWS
permissions:
  id-token: write
  contents: read

jobs:
  # Backend pipeline - runs in parallel with frontend
  lint-backend:
    name: Lint Backend
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true
          cache-dependency-glob: "backend/pyproject.toml"
          version: "0.4.15"

      - name: Lint backend (ruff + mypy)
        working-directory: ./backend
        run: |
          uv sync --frozen
          uv run ruff check . && \
          uv run ruff format --check . && \
          uv run mypy .

  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    needs: lint-backend
    services:
      postgres:
        image: timescale/timescaledb:latest-pg16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true
          cache-dependency-glob: "backend/pyproject.toml"
          version: "0.4.15"

      - name: Run backend tests
        working-directory: ./backend
        env:
          POSTGRES_SERVER: localhost
          POSTGRES_PORT: 5432
          POSTGRES_DB: test_db
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          SECRET_KEY: test-secret-key-for-ci-pipeline
          FIRST_SUPERUSER: test@example.com
          FIRST_SUPERUSER_PASSWORD: testpassword123
          ENVIRONMENT: local
          PROJECT_NAME: gamepulse
        run: |
          uv sync --frozen
          uv run alembic upgrade head
          uv run coverage run -m pytest -v -n 2
          uv run coverage report

  # Frontend pipeline - runs in parallel with backend
  lint-frontend:
    name: Lint Frontend
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Lint frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run lint

  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    needs: lint-frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Run frontend tests (if available)
        working-directory: ./frontend
        run: |
          npm ci
          if npm run test --if-present; then
            echo "Frontend tests passed"
          else
            echo "No frontend tests configured - skipping"
          fi

  # Generate TypeScript client from OpenAPI schema
  generate-client:
    name: Generate Frontend Client
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    permissions:
      contents: write # Override global read-only to allow commits
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true
          cache-dependency-glob: "backend/pyproject.toml"
          version: "0.4.15"

      - name: Install backend dependencies
        working-directory: ./backend
        run: uv sync --frozen

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Generate client
        working-directory: .
        env:
          VIRTUAL_ENV: backend/.venv
          ENVIRONMENT: production
          PROJECT_NAME: gamepulse
          SECRET_KEY: just-for-generating-client
          POSTGRES_SERVER: localhost
          POSTGRES_PORT: 5432
          POSTGRES_DB: test_db
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: just-for-generating-client
          FIRST_SUPERUSER: test@example.com
          FIRST_SUPERUSER_PASSWORD: just-for-generating-client
        run: |
          uv run bash scripts/generate-client.sh

      - name: Commit and push client changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add frontend/src/client
          if git diff --staged --quiet; then
            echo "No client changes detected"
          else
            git commit -m "chore: regenerate frontend client from OpenAPI schema"
            git push
          fi

  # Docker Compose validation - runs independently
  validate-docker:
    name: Validate Docker Compose
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate Docker Compose configuration
        env:
          DOMAIN: localhost
          FRONTEND_HOST: http://localhost:5173
          STACK_NAME: gamepulse
          ENVIRONMENT: local
          POSTGRES_SERVER: db
          POSTGRES_PORT: 5432
          POSTGRES_DB: gamepulse
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: test-password
          SECRET_KEY: test-secret-key
          FIRST_SUPERUSER: test@example.com
          FIRST_SUPERUSER_PASSWORD: test-password
          DOCKER_IMAGE_BACKEND: backend
          DOCKER_IMAGE_FRONTEND: frontend
          TAG: latest
        run: |
          echo "Validating docker-compose files..."
          # Create dummy .env file (docker-compose expects it via env_file directive)
          touch .env
          docker compose -f docker-compose.yml config > /dev/null
          docker compose -f docker-compose.yml -f docker-compose.prod.yml config > /dev/null
          echo "✅ Docker Compose configuration is valid"

  # Build stage - Backend and Frontend build in parallel
  build-backend:
    name: Build and Push Backend Image to ECR
    runs-on: ubuntu-latest
    needs: [test-backend, validate-docker]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActionsECRBuildBackend

      - name: Login to Amazon ECR Public
        id: login-ecr-public
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ secrets.ECR_BACKEND_URL }}:${{ github.sha }}
            ${{ secrets.ECR_BACKEND_URL }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify backend image in ECR
        run: |
          echo "✅ Backend image successfully pushed to ECR Public:"
          echo "   ${{ secrets.ECR_BACKEND_URL }}:${{ github.sha }}"

  build-frontend:
    name: Build and Push Frontend Image to ECR
    runs-on: ubuntu-latest
    needs: [generate-client]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0  # Need full history for git pull

      - name: Pull latest changes (includes generated client)
        run: |
          git pull origin ${{ github.ref_name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActionsECRBuildFrontend

      - name: Login to Amazon ECR Public
        id: login-ecr-public
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ secrets.ECR_FRONTEND_URL }}:${{ github.sha }}
            ${{ secrets.ECR_FRONTEND_URL }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify frontend image in ECR
        run: |
          echo "✅ Frontend image successfully pushed to ECR Public:"
          echo "   ${{ secrets.ECR_FRONTEND_URL }}:${{ github.sha }}"

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActionsDeployment

      - name: Deploy via SSM Session Manager
        env:
          INSTANCE_ID: ${{ secrets.AWS_EC2_INSTANCE_ID }}
        run: |
          echo "Deploying to EC2 instance: $INSTANCE_ID via SSM Session Manager"

          # Send deployment script via SSM and execute
          # Note: SSM runs as ssm-user by default, so we use sudo to run as ubuntu user
          # Note: Pulls pre-built images from ECR Public (no authentication required for public repos)
          # Secrets are fetched from Parameter Store during deployment
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "GitHub Actions deployment via OIDC with Parameter Store secrets" \
            --parameters 'commands=["sudo -u ubuntu bash -c '\''cd /opt/gamepulse && echo \"Pulling latest config from main...\" && git fetch origin main && git reset --hard origin/main && echo \"Loading secrets from Parameter Store...\" && bash backend/scripts/create-env-from-aws-parameters.sh production .env && echo \"Pulling pre-built images from ECR Public...\" && docker compose -f docker-compose.yml -f docker-compose.prod.yml pull && echo \"Restarting services...\" && docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --force-recreate && echo \"Deployment complete!\" && docker compose -f docker-compose.yml -f docker-compose.prod.yml ps && echo \"Cleaning up...\" && docker image prune -f'\''"]' \
            --output text \
            --query "Command.CommandId" > /tmp/command_id.txt

          COMMAND_ID=$(cat /tmp/command_id.txt)
          echo "SSM Command ID: $COMMAND_ID"

          # Wait for command to complete (max 10 minutes)
          echo "Waiting for deployment to complete..."
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")

            echo "Attempt $i/60: Command status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment completed successfully"

              # Get command output
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text

              exit 0
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "❌ Deployment failed with status: $STATUS"

              # Get error output
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardErrorContent" \
                --output text

              exit 1
            fi

            sleep 10
          done

          echo "❌ Deployment timed out after 10 minutes"
          exit 1

  smoke-test:
    name: Smoke Test Deployment
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Wait for services to stabilize
        run: |
          echo "Waiting 30 seconds for services to fully start..."
          sleep 30

      - name: Health check with retry logic
        run: |
          echo "Starting health check for https://api.gamepulse.top/api/v1/health"
          echo "Note: First deployment may take 2-5 minutes for Let's Encrypt certificate provisioning"

          MAX_ATTEMPTS=12
          RETRY_DELAY=30

          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i of $MAX_ATTEMPTS..."

            # Try HTTPS health check
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              "https://api.gamepulse.top/api/v1/health" || echo "000")

            if [ "$RESPONSE" = "200" ]; then
              echo "✅ Health check passed! HTTP $RESPONSE"

              BODY=$(curl -s "https://api.gamepulse.top/api/v1/health")
              echo "Response body: $BODY"

              if echo "$BODY" | jq -e '.status == "healthy" and .database == "connected"' > /dev/null 2>&1; then
                echo "✅ Health endpoint returned healthy status with database connected"
                echo "Total wait time: $((($i - 1) * $RETRY_DELAY + 30)) seconds"
                exit 0
              else
                echo "⚠️ Health endpoint returned non-healthy status: $BODY"
              fi
            elif [ "$RESPONSE" = "000" ]; then
              echo "❌ Connection failed (certificate provisioning may be in progress)"
            else
              echo "❌ Health check failed with HTTP $RESPONSE"
            fi

            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Waiting ${RETRY_DELAY} seconds before retry..."
              sleep $RETRY_DELAY
            fi
          done

          echo "❌ Health check failed after $MAX_ATTEMPTS attempts ($(($MAX_ATTEMPTS * $RETRY_DELAY / 60)) minutes)"
          echo "This may indicate a certificate provisioning or routing issue"
          exit 1
